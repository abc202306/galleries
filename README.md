---
ctime: 2025-12-17T20:55:15+08:00
mtime: 2026-01-02T14:59:59+08:00
---

# README

![](/docs/image-file/obsidian-vault-galleries-graph-view-image.png)

> [!Note]
> 1. [[#pinned\|#pinned]]
> 2. [[#Web Clipper\|#Web Clipper]]
> 3. [[#Folder Struct\|#Folder Struct]]
> 4. [[#Views of gallery-base.base\|#Views of gallery-base.base]]
> 5. [[#Script\|#Script]]

## pinned

- [[gallery]]
- [[tag]]
- [[gallery-notes]]

## Web Clipper

- EXHentai Web Clipper for Obsidian | https://github.com/abc202306/exhentai-web-clipper-for-obsidian
- NHentai Web Clipper for Obsidian | https://github.com/abc202306/nhentai-web-clipper-for-obsidian

## Folder Struct

> DFC stands for the total number of descendant files

| Folder Path | DFC | DFMC | DFOC |
| :--- | ---: | ---: | ---: |
| [[docs\|docs]] | 55 | 50 | 5 |
| [[docs\|docs]]/[[base-file\|base-file]] | 3 | 0 | 3 |
| [[docs\|docs]]/[[canvas\|canvas]] | 1 | 0 | 1 |
| [[docs\|docs]]/[[collection\|collection]] | 2 | 2 | 0 |
| [[docs\|docs]]/[[docs\|docs]] | 14 | 14 | 0 |
| [[docs\|docs]]/[[galleries\|galleries]] | 2 | 2 | 0 |
| [[docs\|docs]]/[[image-file\|image-file]] | 1 | 0 | 1 |
| [[docs\|docs]]/[[notation\|notation]] | 1 | 1 | 0 |
| [[docs\|docs]]/[[property\|property]] | 4 | 4 | 0 |
| [[docs\|docs]]/[[tag\|tag]] | 14 | 14 | 0 |
| [[docs\|docs]]/[[year\|year]] | 13 | 13 | 0 |
| [[galleries\|galleries]] | 1396 | 698 | 698 |
| [[galleries\|galleries]]/[[exhentai\|exhentai]] | 590 | 295 | 295 |
| [[galleries\|galleries]]/[[exhentai\|exhentai]]/[[2012\|2012]] | 2 | 1 | 1 |
| [[galleries\|galleries]]/[[exhentai\|exhentai]]/[[2014\|2014]] | 2 | 1 | 1 |
| [[galleries\|galleries]]/[[exhentai\|exhentai]]/[[2015\|2015]] | 4 | 2 | 2 |
| [[galleries\|galleries]]/[[exhentai\|exhentai]]/[[2016\|2016]] | 6 | 3 | 3 |
| [[galleries\|galleries]]/[[exhentai\|exhentai]]/[[2017\|2017]] | 16 | 8 | 8 |
| [[galleries\|galleries]]/[[exhentai\|exhentai]]/[[2018\|2018]] | 14 | 7 | 7 |
| [[galleries\|galleries]]/[[exhentai\|exhentai]]/[[2019\|2019]] | 12 | 6 | 6 |
| [[galleries\|galleries]]/[[exhentai\|exhentai]]/[[2020\|2020]] | 16 | 8 | 8 |
| [[galleries\|galleries]]/[[exhentai\|exhentai]]/[[2021\|2021]] | 18 | 9 | 9 |
| [[galleries\|galleries]]/[[exhentai\|exhentai]]/[[2022\|2022]] | 26 | 13 | 13 |
| [[galleries\|galleries]]/[[exhentai\|exhentai]]/[[2023\|2023]] | 40 | 20 | 20 |
| [[galleries\|galleries]]/[[exhentai\|exhentai]]/[[2024\|2024]] | 100 | 50 | 50 |
| [[galleries\|galleries]]/[[exhentai\|exhentai]]/[[2025\|2025]] | 334 | 167 | 167 |
| [[galleries\|galleries]]/[[nhentai\|nhentai]] | 806 | 403 | 403 |
| [[galleries\|galleries]]/[[nhentai\|nhentai]]/[[2014\|2014]] | 26 | 13 | 13 |
| [[galleries\|galleries]]/[[nhentai\|nhentai]]/[[2015\|2015]] | 18 | 9 | 9 |
| [[galleries\|galleries]]/[[nhentai\|nhentai]]/[[2016\|2016]] | 18 | 9 | 9 |
| [[galleries\|galleries]]/[[nhentai\|nhentai]]/[[2017\|2017]] | 24 | 12 | 12 |
| [[galleries\|galleries]]/[[nhentai\|nhentai]]/[[2018\|2018]] | 42 | 21 | 21 |
| [[galleries\|galleries]]/[[nhentai\|nhentai]]/[[2019\|2019]] | 28 | 14 | 14 |
| [[galleries\|galleries]]/[[nhentai\|nhentai]]/[[2020\|2020]] | 46 | 23 | 23 |
| [[galleries\|galleries]]/[[nhentai\|nhentai]]/[[2021\|2021]] | 38 | 19 | 19 |
| [[galleries\|galleries]]/[[nhentai\|nhentai]]/[[2022\|2022]] | 58 | 29 | 29 |
| [[galleries\|galleries]]/[[nhentai\|nhentai]]/[[2023\|2023]] | 76 | 38 | 38 |
| [[galleries\|galleries]]/[[nhentai\|nhentai]]/[[2024\|2024]] | 164 | 82 | 82 |
| [[galleries\|galleries]]/[[nhentai\|nhentai]]/[[2025\|2025]] | 268 | 134 | 134 |
| [[gallery-notes\|gallery-notes]] | 7 | 5 | 2 |
| [[property\|property]] | 33 | 33 | 0 |
| [[property\|property]]/[[basic-property\|basic-property]] | 8 | 8 | 0 |
| [[property\|property]]/[[docs-property\|docs-property]] | 1 | 1 | 0 |
| [[property\|property]]/[[gallery-notes-property\|gallery-notes-property]] | 1 | 1 | 0 |
| [[property\|property]]/[[gallery-property\|gallery-property]] | 23 | 23 | 0 |
| [[tag\|tag]] | 1609 | 1609 | 0 |
| [[tag\|tag]]/[[artist\|artist]] | 538 | 538 | 0 |
| [[tag\|tag]]/[[categories\|categories]] | 10 | 10 | 0 |
| [[tag\|tag]]/[[character\|character]] | 270 | 270 | 0 |
| [[tag\|tag]]/[[cosplayer\|cosplayer]] | 1 | 1 | 0 |
| [[tag\|tag]]/[[female\|female]] | 251 | 251 | 0 |
| [[tag\|tag]]/[[group-ns\|group-ns]] | 252 | 252 | 0 |
| [[tag\|tag]]/[[keywords\|keywords]] | 74 | 74 | 0 |
| [[tag\|tag]]/[[language\|language]] | 9 | 9 | 0 |
| [[tag\|tag]]/[[location\|location]] | 4 | 4 | 0 |
| [[tag\|tag]]/[[male\|male]] | 54 | 54 | 0 |
| [[tag\|tag]]/[[mixed\|mixed]] | 7 | 7 | 0 |
| [[tag\|tag]]/[[other\|other]] | 33 | 33 | 0 |
| [[tag\|tag]]/[[parody\|parody]] | 105 | 105 | 0 |
| [[tag\|tag]]/[[temp\|temp]] | 1 | 1 | 0 |
| [[templates\|templates]] | 2 | 2 | 0 |
| [[uploader\|uploader]] | 167 | 167 | 0 |

## Views of [[gallery-base.base\|gallery-base.base]]

> [!Note]
> 
> 1. [[#artist\|#artist]]
> 2. [[#categories\|#categories]]
> 3. [[#parody\|#parody]]
> 4. [[#female\|#female]]
> 5. [[#male\|#male]]
> 6. [[#mixed\|#mixed]]
> 7. [[#character\|#character]]

### artist

> seealso: [[gallery-base.base#artist|artist]]

1. [[gallery-base.base#artist/kiira|kiira]] | 5 | [[exhentai-tag-kiira\|kiira]]
2. [[gallery-base.base#artist/henreader|henreader]] | 5 | [[exhentai-tag-henreader\|henreader]]
3. [[gallery-base.base#artist/utatane|utatane]] | 4 | [[exhentai-tag-utatane\|utatane]]
4. [[gallery-base.base#artist/wancho|wancho]] | 5 | [[exhentai-tag-wancho\|wancho]]
5. [[gallery-base.base#artist/custom-udon|custom-udon]] | 3 | [[exhentai-tag-custom-udon\|custom-udon]]
6. [[gallery-base.base#artist/komugi|komugi]] | 3 | [[exhentai-tag-komugi\|komugi]]
7. [[gallery-base.base#artist/hikami-izuto|hikami-izuto]] | 2 | [[exhentai-tag-hikami-izuto\|hikami-izuto]]
8. [[gallery-base.base#artist/murai-renji|murai-renji]] | 1 | [[exhentai-tag-murai-renji\|murai-renji]]
9. [[gallery-base.base#artist/yoyomax|yoyomax]] | 1 | [[exhentai-tag-yoyomax\|yoyomax]]
10. [[gallery-base.base#artist/kani-biimu|kani-biimu]] | 1 | [[exhentai-tag-kani-biimu\|kani-biimu]]
11. [[gallery-base.base#artist/baku-p|baku-p]] | 1 | [[exhentai-tag-baku-p\|baku-p]]

### categories

> seealso: [[gallery-base.base#categories|categories]]

1. [[gallery-base.base#categories/doujinshi|doujinshi]] | 463 | [[exhentai-tag-doujinshi\|doujinshi]]
2. [[gallery-base.base#categories/manga|manga]] | 114 | [[exhentai-tag-manga\|manga]]
3. [[gallery-base.base#categories/image-set|image-set]] | 37 | [[exhentai-tag-image-set\|image-set]]
4. [[gallery-base.base#categories/misc|misc]] | 23 | [[exhentai-tag-misc\|misc]]
5. [[gallery-base.base#categories/artist-cg|artist-cg]] | 33 | [[exhentai-tag-artist-cg\|artist-cg]]
6. [[gallery-base.base#categories/game-cg|game-cg]] | 8 | [[exhentai-tag-game-cg\|game-cg]]
7. [[gallery-base.base#categories/non-h|non-h]] | 4 | [[exhentai-tag-non-h\|non-h]]
8. [[gallery-base.base#categories/western|western]] | 1 | [[exhentai-tag-western\|western]]

### parody

> seealso: [[gallery-base.base#parody|parody]]

1. [[gallery-base.base#parody/original|original]] | 193 | [[exhentai-tag-original\|original]]
2. [[gallery-base.base#parody/blue-archive|blue-archive]] | 93 | [[exhentai-tag-blue-archive\|blue-archive]]
3. [[gallery-base.base#parody/touhou-project|touhou-project]] | 25 | [[exhentai-tag-touhou-project\|touhou-project]]
4. [[gallery-base.base#parody/mahoujin-guru-guru|mahoujin-guru-guru]] | 20 | [[exhentai-tag-mahoujin-guru-guru\|mahoujin-guru-guru]]

### female

1. [[gallery-base.base#female/lolicon|lolicon]] | 644 | [[exhentai-tag-lolicon\|lolicon]]
2. [[gallery-base.base#female/rape|rape]] | 106 | [[exhentai-tag-rape\|rape]]

### male

1. [[gallery-base.base#male/sole-male|sole-male]] | 293 | [[exhentai-tag-sole-male\|sole-male]]

### mixed

1. [[gallery-base.base#mixed/kodomo-doushi|kodomo-doushi]] | 27 | [[exhentai-tag-kodomo-doushi\|kodomo-doushi]]

### character

1. [[gallery-base.base#character/kukuri|kukuri]] | 19 | [[exhentai-tag-kukuri\|kukuri]]

## Script

### Build Index Content

```js

const config = {
    path: {
        folder: {
            tag: "tag/", //type/rewrite
            gallery: "galleries/", //type/rewrite
            property: "property/", //type/rewrite
            uploader: "uploader/", //type/rewrite
            docsTag: "docs/tag/", //type/rewrite
            docsYear: "docs/year/", //type/rewrite
        },
        file: {
            readme: "README.md", //type/replace
            tag: "docs/docs/tag.md", //type/rewrite
            uploader: "docs/docs/uploader.md", //type/rewrite
            galleryNotes: "docs/collection/gallery-notes.md", //type/replace
            gallery: "docs/collection/gallery.md", //type/replace
            exhentai: "docs/galleries/exhentai.md", //type/replace
            nhentai: "docs/galleries/nhentai.md", //type/replace
        },
    },
};

function getLocalISOStringWithTimezone() {
    const date = new Date();
    const pad = (n) => String(n).padStart(2, "0");

    const offset = -date.getTimezoneOffset();
    const sign = offset >= 0 ? "+" : "-";
    const hours = pad(Math.floor(Math.abs(offset) / 60));
    const minutes = pad(Math.abs(offset) % 60);

    return (
        `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}T` +
        `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}` +
        `${sign}${hours}:${minutes}`
    );
}

// Utility helpers to avoid relying on environment-specific prototype extensions
function uniqueArray(arr) {
    return Array.from(new Set(arr));
}

function groupBy(array, keyFn) {
    const map = new Map();
    for (const item of array) {
        const key = keyFn(item);
        const list = map.get(key) || [];
        list.push(item);
        map.set(key, list);
    }
    return Array.from(map.entries());
}

function safeArray(v) {
    if (!v) return [];
    return Array.isArray(v) ? v : [v];
}

function compareGalleryPathWithPropertyUploaded(path1, path2) {
    const f1 = app.vault.getAbstractFileByPath(path1);
    const f2 = app.vault.getAbstractFileByPath(path2);
    const fc1 = app.metadataCache.getFileCache(f1);
    const fc2 = app.metadataCache.getFileCache(f2);
    const v1 = String(fc1?.frontmatter?.uploaded || "_");
    const v2 = String(fc2?.frontmatter?.uploaded || "_");
    // sort descending
    return v2.localeCompare(v1);
}

function getGalleryPathRepresentationStr(path) {
    const f2 = app.vault.getAbstractFileByPath(path);
    const linktext2 = app.metadataCache.fileToLinktext(f2);
    const fc2 = app.metadataCache.getFileCache(f2) || {};

	const dateUploaded = fc2.frontmatter?.uploaded?.substring(0,10);
	const postDescription = dateUploaded?` | ${dateUploaded}`:"";
	
    const display2 = fc2.frontmatter?.japanese || fc2.frontmatter?.english || linktext2;
    const link2 =
        display2 === linktext2
            ? `| [[${linktext2}\\|${linktext2}]]`
            : `\u001C${display2}\u001C | [[${linktext2}\\|${linktext2}]]`.replace(/\u001C/g, "`");

    const coverField = fc2.frontmatter?.cover;
    let coverEmbed = "";
    if (coverField) {
        const res = /^\[\[(?<linktext3>[^\|]*)\|?.*\]\]$/.exec(coverField);
        coverEmbed = res
            ? `\n\t- ![[${res.groups.linktext3}|200]]`
            : `\n\t- ![200](${coverField})`;
    }

    return `1. ${link2}${postDescription}${coverEmbed}`;
}

function getNGStr(nonGalleryNotePaths) {
    const ngls = [...nonGalleryNotePaths].sort();
    return ngls
        .map((path) => `[[${app.metadataCache.fileToLinktext(app.vault.getAbstractFileByPath(path))}\\|${app.metadataCache.fileToLinktext(app.vault.getAbstractFileByPath(path))}]]`)
        .join(", ");
}

function getGStrASList(galleryNotePaths) {
    const gls = [...galleryNotePaths].sort(compareGalleryPathWithPropertyUploaded);
    return gls.map(getGalleryPathRepresentationStr).join("\n");
}

function getGStrASGroupedList(galleryNotePaths) {
    const gls = [...galleryNotePaths].sort(compareGalleryPathWithPropertyUploaded);
    const grouped = groupBy(gls, (gnPath) => getYear(app.vault.getAbstractFileByPath(gnPath)));
    const parts = grouped
        .sort((a, b) => b[0].localeCompare(a[0]))
        .flatMap(([key, group]) => {
			const grouped02 = groupBy(group, (gnPath) => getMonth(app.vault.getAbstractFileByPath(gnPath)));
			const parts02 = grouped02
		        .sort((a, b) => b[0].localeCompare(a[0]))
				.flatMap(([key02, group02]) => [
					`#### ${key02}`,
					group02.map(getGalleryPathRepresentationStr).join("\n")
				])
			return [
				`### ${key}`,
				...parts02
			]
		});
    return parts.join("\n\n");
}

function getGStr(galleryNotePaths) {
    return getGStrASGroupedList(galleryNotePaths);
}

function getTagFileContent(title, ctime, mtime) {
    const f = app.metadataCache.getFirstLinkpathDest(title);
    const backlinks = app.metadataCache.getBacklinksForFile(f)?.data;
    const paths = backlinks ? [...backlinks.keys()] : [];

    const ngstr = getNGStr(
        paths.filter((i) => !i.startsWith(config.path.folder.gallery)).filter((i) => i !== config.path.file.readme)
    );
    const gstr = getGStr(paths.filter((i) => i.startsWith(config.path.folder.gallery)));

    return `---\nctime: ${ctime}\nmtime: ${mtime}\n---\n\n# ${title}\n\n> seealso: ${ngstr}\n\n![[gallery-dynamic-base.base\\|gallery-dynamic-base.base]]\n\n## gallery-items\n\n${gstr}\n`;
}

function getYearFileContent(title, ctime, mtime) {
    const f = app.metadataCache.getFirstLinkpathDest(title);
    const backlinks = app.metadataCache.getBacklinksForFile(f)?.data;
    const paths = backlinks ? [...backlinks.keys()] : [];

    const ngstr = getNGStr(
        paths.filter((i) => !i.startsWith(config.path.folder.gallery)).filter((i) => i !== config.path.file.readme)
    );

    const galleryNotePaths = app
        .vault
        .getMarkdownFiles()
        .filter((f) => f.path.startsWith(config.path.folder.gallery))
        .filter((f) => getYear(f) === title)
        .map((f) => f.path);
    const gstr = getGStr(galleryNotePaths);

    return `---\nctime: ${ctime}\nmtime: ${mtime}\n---\n\n# ${title}\n\n> seealso: ${ngstr}\n\n## gallery-items\n\n${gstr}\n`;
}

function toFileName(wikilinkStr) {
	return /^\[\[(?<fn>[^\|]*?)\|.*?\]\]$/.exec(wikilinkStr).groups.fn || /^\[\[(?<fn>[^\|]*?)\]\]$/.exec(wikilinkStr).groups.fn || "_";
}

function getTagGroupMOC(title) {
    const property = title.replace(/-ns$/, "");
    const galleryMDFileCaches = app
        .vault
        .getMarkdownFiles()
        .filter((f) => f.path.startsWith(config.path.folder.gallery))
        .map((f) => app.metadataCache.getFileCache(f) || {});

    const allValues = galleryMDFileCaches.flatMap((fc) => safeArray((fc.frontmatter || {})[property]));
    const uniqueValues = uniqueArray(allValues).filter((v) => v);

    return uniqueValues
        .sort((a, b) => toFileName(a).localeCompare(toFileName(b)))
        .map((v) =>
            `1. ${v} | ${galleryMDFileCaches.filter((fc) => safeArray((fc.frontmatter || {})[property]).includes(v)).length}`
        )
        .join("\n");
}

function getGroupFileContent(title, ctime, mtime, seealso) {
    return `---\nctime: ${ctime}\nmtime: ${mtime}\n---\n\n# ${title}\n\n> seealso: ${seealso}\n\n${getTagGroupMOC(title)}\n`;
}

function getTagCount(tagNameSpaceStr) {
    const property = tagNameSpaceStr.replace(/-ns$/, "");
    const galleryMDFileCaches = app
        .vault
        .getMarkdownFiles()
        .filter((f) => f.path.startsWith(config.path.folder.gallery))
        .map((f) => app.metadataCache.getFileCache(f) || {});

    return uniqueArray(galleryMDFileCaches.flatMap((fc) => safeArray((fc.frontmatter || {})[property]))).filter((v) => v)
        .length;
}

function getTagMetaFileContent(_title, ctime, mtime) {
    return `---\nctime: ${ctime}\nmtime: ${mtime}\n---\n\n# tag\n\n> seealso: [[docs\\|docs]]\n\n1. [[artist\\|artist]] | ${getTagCount("artist")}\n1. [[categories\\|categories]] | ${getTagCount("categories")}\n1. [[character\\|character]] | ${getTagCount("character")}\n1. [[cosplayer\\|cosplayer]] | ${getTagCount("cosplayer")}\n1. [[female\\|female]] | ${getTagCount("female")}\n1. [[group-ns\\|group-ns]] | ${getTagCount("group-ns")}\n1. [[keywords\\|keywords]] | ${getTagCount("keywords")}\n1. [[language\\|language]] | ${getTagCount("language")}\n1. [[location\\|location]] | ${getTagCount("location")}\n1. [[male\\|male]] | ${getTagCount("male")}\n1. [[mixed\\|mixed]] | ${getTagCount("mixed")}\n1. [[other\\|other]] | ${getTagCount("other")}\n1. [[parody\\|parody]] | ${getTagCount("parody")}\n1. [[temp\\|temp]] | ${getTagCount("temp")}\n`;
}

function getTagGroupFileContent(title, ctime, mtime) {
    return getGroupFileContent(title, ctime, mtime, "[[tag\\|tag]]");
}

function getUploaderGroupFileContent(title, ctime, mtime) {
    return getGroupFileContent(title, ctime, mtime, "[[docs\\|docs]]");
}

function getPropertyFileContent(title, ctime, mtime) {
    const f = app.metadataCache.getFirstLinkpathDest(title);
    const backlinks = app.metadataCache.getBacklinksForFile(f)?.data;
    const paths = backlinks ? [...backlinks.keys()] : [];

    const ngstr = getNGStr(
        paths.filter((i) => !i.startsWith(config.path.folder.gallery)).filter((i) => i !== config.path.file.readme)
    );

    return `---\nctime: ${ctime}\nmtime: ${mtime}\n---\n\n# ${title}\n\n> seealso: ${ngstr}\n\n![[property-dynamic-base.base\\|property-dynamic-base.base]]\n`;
}

function getRenderedFolderPath(folder) {
    return folder.path.split("/").map((part) => `[[${part}\\|${part}]]`).join("/");
}



function getDecendantFilesCount(folder, files, extension=/.*/) {
    return files.filter((f) => f.path.startsWith(folder.path + "/") && extension.exec(f.extension)).length;
}

function replaceFrontMatter(fileContent, ctime, mtime, preFMBlock = "") {
    return `---${preFMBlock}\nctime: ${ctime}\nmtime: ${mtime}\n---\n` + fileContent.replace(/^---\r?\n[^]*?(?<=\n)---\r?\n/, "");
}

async function getReadmeFileContent(_title, ctime, mtime) {
    const file = app.vault.getAbstractFileByPath(config.path.file.readme);
    const fileContent = await app.vault.read(file);

    const files = app.vault.getFiles();
    const folders = app.vault.getAllFolders().sort((a, b) => a.path.localeCompare(b.path));

    const tableStr = `| Folder Path | DFC | DFMC | DFOC |\n| :--- | ---: | ---: | ---: |\n${folders
        .map((folder) => `| ${getRenderedFolderPath(folder)} | ${getDecendantFilesCount(folder, files, /.*/)} | ${getDecendantFilesCount(folder, files, /^md$/)} | ${getDecendantFilesCount(folder, files, /^(?!md$)/)} |`)
        .join("\n")}`;

    const newData = replaceFrontMatter(fileContent, ctime, mtime).replace(
        /(?<=\n)## Folder Struct\n[^#]*(?=\n##\s)/,
        "## Folder Struct\n\n> DFC stands for the total number of descendant files\n\n" + tableStr + "\n"
    );

    return newData;
}

async function getNoteMetaFileContent(_title, ctime, mtime) {
    const metaFilePath = config.path.file.galleryNotes;
    const noteFiles = app
        .vault
        .getMarkdownFiles()
        .filter((f) => safeArray(app.metadataCache.getFileCache(f)?.frontmatter?.up).includes("[[gallery-notes|gallery-notes]]"));

    const file = app.vault.getAbstractFileByPath(metaFilePath);
    const fileContent = await app.vault.read(file);

    const gls = noteFiles
        .sort((f1, f2) => {
            const fc1 = app.metadataCache.getFileCache(f1) || {};
            const fc2 = app.metadataCache.getFileCache(f2) || {};
            const v1 = fc1.frontmatter?.ctime || "_";
            const v2 = fc2.frontmatter?.ctime || "_";
            return v2.localeCompare(v1);
        })
        .map((f) => f.path);

    const gstr = gls.map(getGalleryPathRepresentationStr).join("\n");

    const preFMBlock = `\nup:\n  - "[[collection|collection]]"`;
    const newData = replaceFrontMatter(fileContent, ctime, mtime, preFMBlock).replace(/(?<=\n)## note-list\n[^]*/,
        "## note-list\n\n" + gstr + "\n"
    );

    return newData;
}


async function getGalleryMetaFileContentWithSpecPath(_title, ctime, mtime, metaFilePath, galleryNoteFiles, preFMBlock = "") {
    const file = app.vault.getAbstractFileByPath(metaFilePath);
    const fileContent = await app.vault.read(file);

    const gstr = getGStr(galleryNoteFiles.map((f) => f.path));

    const newData = replaceFrontMatter(fileContent, ctime, mtime, preFMBlock).replace(/(?<=\n)## gallery-items\n[^]*/,
        "## gallery-items\n\n" + gstr + "\n"
    );

    return newData;
}

async function getSpecGalleryMetaFileContent(_title, ctime, mtime) {
    const metaFilePath = config.path.file.gallery;
    const galleryNoteFiles = app
        .vault
        .getMarkdownFiles()
        .filter((f) => safeArray(app.metadataCache.getFileCache(f)?.frontmatter?.up).includes("[[gallery|gallery]]"));
    const preFMBlock = `\nup:\n  - "[[collection|collection]]"\nbases:\n  - "[[gallery-base.base|gallery-base.base]]"`;
    return await getGalleryMetaFileContentWithSpecPath(_title, ctime, mtime, metaFilePath, galleryNoteFiles, preFMBlock);
}

async function getSpecEXHentaiGalleryMetaFileContent(_title, ctime, mtime) {
    const metaFilePath = config.path.file.exhentai;
    const galleryNoteFiles = app
        .vault
        .getMarkdownFiles()
        .filter((f) => safeArray(app.metadataCache.getFileCache(f)?.frontmatter?.up).includes("[[gallery|gallery]]"))
        .filter((f) => (app.metadataCache.getFileCache(f)?.frontmatter?.url || "").includes("exhentai"));
    return await getGalleryMetaFileContentWithSpecPath(_title, ctime, mtime, metaFilePath, galleryNoteFiles);
}

async function getSpecNHentaiGalleryMetaFileContent(_title, ctime, mtime) {
    const metaFilePath = config.path.file.nhentai;
    const galleryNoteFiles = app
        .vault
        .getMarkdownFiles()
        .filter((f) => safeArray(app.metadataCache.getFileCache(f)?.frontmatter?.up).includes("[[gallery|gallery]]"))
        .filter((f) => (app.metadataCache.getFileCache(f)?.frontmatter?.url || "").includes("nhentai"));
    return await getGalleryMetaFileContentWithSpecPath(_title, ctime, mtime, metaFilePath, galleryNoteFiles);
}

async function getFileContent(file, data, getSpecTypeFileContent) {
    const title = file.basename;
    const fileCache = app.metadataCache.getFileCache(file) || {};

    const ctimeInFrontMatter = fileCache.frontmatter?.ctime;
    const mtimeInFrontMatter = fileCache.frontmatter?.mtime;

    const mtime = getLocalISOStringWithTimezone();
    const ctime = ctimeInFrontMatter || mtime;

    const formattedData = data.replace(/\r/g, "");

    const newData1 = await getSpecTypeFileContent(title, ctimeInFrontMatter, mtimeInFrontMatter);
    if (formattedData === newData1) return data;

    const newData2 = await getSpecTypeFileContent(title, ctime, mtime);
    return newData2;
}

function processFileWith(getSpecTypeFileContent) {
    return async function processFileWrapper(file) {
        const originalData = await app.vault.read(file);
        const newData = await getFileContent(file, originalData, getSpecTypeFileContent);
        if (newData !== originalData) {
            await app.vault.process(file, () => newData);
        }
    };
}

function removeDuplicatedValueInArrayPropertyInFrontmatterForAllMarkdownFiles() {
    app.vault.getMarkdownFiles().forEach((f) => {
        const fc = app.metadataCache.getFileCache(f) || {};
        if (!fc.frontmatter) return;
        for (const k of Object.keys(fc.frontmatter)) {
            const v1 = fc.frontmatter[k];
            if (!Array.isArray(v1)) continue;
            const v2 = uniqueArray(v1);
            if (v2.length === v1.length) continue;
            app.fileManager.processFrontMatter(f, (fm) => {
                fm[k] = v2;
            });
        }
    });
}

function createFilesFromUnresolvedLinksForAllGalleryNoteFiles() {
    const galleryNoteMDFiles = app.vault.getMarkdownFiles().filter((f) => f.path.startsWith(config.path.folder.gallery));
    const unresolvedLinktexts = galleryNoteMDFiles.flatMap((f) => Object.keys(app.metadataCache.unresolvedLinks?.[f.path] || {}));

	console.log("unresolvedLinktexts",unresolvedLinktexts)

    const propertyNames = [
        "artist",
        "group",
        "categories",
        "character",
        "parody",
        "language",
        "cosplayer",
        "female",
        "location",
        "male",
        "mixed",
        "other",
        "temp",
        "keywords",
		"uploader",
    ];

    const galleryMDFileCaches = galleryNoteMDFiles.map((f) => app.metadataCache.getFileCache(f) || {});
    for (const linktext of uniqueArray(unresolvedLinktexts)) {
        const value = `[[${linktext}\\|${linktext}]]`;
        const propertyName = propertyNames.find((pn) =>
            galleryMDFileCaches.filter((fc) => safeArray((fc.frontmatter || {})[pn]).includes(value)).length !== 0
        );

        let folderPath = config.path.folder.tag;
        if (propertyName === "group") {
            folderPath += "group-ns/";
        } else if (propertyName === "uploader") {
			folderPath = config.path.folder.uploader;
		} else if (propertyName) {
			folderPath += `${propertyName}/`
		}

        const destPath = folderPath + linktext + ".md";
        try {
            if (!app.vault.getAbstractFileByPath(destPath)) {
                app.vault.create(destPath, "")
					.then((f)=>app.metadataCache.getFileCache(f));
            }
        } catch (e) {
            // ignore creation errors (file may exist already or race conditions)
        }
    }
}

function getProcessFilePromise(path, getSpecTypeFileContent) {
    const file = app.vault.getAbstractFileByPath(path);
    const fileProcesser = processFileWith(getSpecTypeFileContent);
    return fileProcesser(file);
}

function getYear(galleryNoteFile) {
    return app.metadataCache.getFileCache(galleryNoteFile)?.frontmatter?.uploaded?.slice(0, 4) || "1000";
}

function getMonth(galleryNoteFile) {
    return app.metadataCache.getFileCache(galleryNoteFile)?.frontmatter?.uploaded?.slice(0, 7) || "1000-01";
}

function batchMoveGalleryNoteFilesByYearUploaded() {
    const files = app.vault.getFiles();
    const mdfiles = app.vault.getMarkdownFiles();
    const candidates = mdfiles.filter((f) => f.path.startsWith(config.path.folder.gallery));

    for (const f of candidates) {
        if (f.path.split("/").length !== 3) continue;
        const year = getYear(f);
        const folderPath = `${f.parent.path}/${year}`;
        if (!app.vault.getFolderByPath(folderPath)) app.vault.createFolder(folderPath);
    }

    for (const f of candidates) {
        if (f.path.split("/").length !== 3) continue;
        const year = app.metadataCache.getFileCache(f)?.frontmatter?.uploaded?.slice(0, 4);
        const folderPath = `${f.parent.path}/${year}`;
        if (!app.vault.getFolderByPath(folderPath)) app.vault.createFolder(folderPath);
        const pathPrefix = `${f.parent.path}/${f.basename}`;
        files.filter((f2) => f2.path.startsWith(pathPrefix)).forEach((f2) => {
            const newPath2 = `${folderPath}/${f2.name}`;
            app.vault.rename(f2, newPath2);
            console.log(newPath2);
        });
    }
}

function stardandnizeGalleryNoteCoverFileName() {
	const galleryNoteFiles = app.vault.getMarkdownFiles().filter(f=>f.path.startsWith(config.path.folder.gallery));
	galleryNoteFiles.filter(f=>{
	    const cover = app.metadataCache.getFileCache(f)?.frontmatter?.cover;
	    const res = /^\[\[(.*?\|)?(?<basename>.*)\.(?<extension>.*)\]\]$/.exec(cover)
	    if (!res){
	        return;
	    }
	    const coverBasename = res.groups.basename;
	    const coverExtension = res.groups.extension;
	    const coverLinktext = `${coverBasename}.${coverExtension}`;
	    const coverFile = app.metadataCache.getFirstLinkpathDest(coverLinktext);
	    const newCoverLinktext = `${f.basename}.${coverExtension}`;
		const newPath = `${coverFile.parent.path}/${newCoverLinktext}`
	    if (!cover?.startsWith("[["+f.basename)) {
	        app.fileManager.renameFile(coverFile,newCoverLinktext);
	        console.log(coverFile.name,newPath);
	    }
	})
}

function refreshCache(){
	app.vault.getMarkdownFiles().forEach((f)=>app.metadataCache.getFileCache(f));
}

async function main() {
    console.time("run_script");
    console.log(`==start (time="${new Date()}")`);
	
    const tasks = [];

    // preparatory runs
	tasks.push(refreshCache());

	await Promise.all(tasks);
	
	tasks.push(createFilesFromUnresolvedLinksForAllGalleryNoteFiles());
    tasks.push(batchMoveGalleryNoteFilesByYearUploaded());
	tasks.push(stardandnizeGalleryNoteCoverFileName());

	await Promise.all(tasks);

    // single-file generators
    const singleFileSpecs = [
        [config.path.file.readme, getReadmeFileContent],
        [config.path.file.uploader, getUploaderGroupFileContent],
        [config.path.file.tag, getTagMetaFileContent],
        [config.path.file.galleryNotes, getNoteMetaFileContent],
        [config.path.file.gallery, getSpecGalleryMetaFileContent],
        [config.path.file.exhentai, getSpecEXHentaiGalleryMetaFileContent],
        [config.path.file.nhentai, getSpecNHentaiGalleryMetaFileContent],
    ];

    for (const [path, fn] of singleFileSpecs) {
        tasks.push((async () => {
            try {
				const timerName = "timer-"+fn.name+"-"+path;
				console.time(timerName);
                console.log("started:", fn.name, path);
                await getProcessFilePromise(path, fn);
                console.log("ended:", fn.name, path);
				console.timeEnd(timerName);
            } catch (e) {
                console.error("error processing", path, e);
            }
        })());
    }

	await Promise.all(tasks);
	
	tasks.push(refreshCache());
	
    // directory-scoped generators
    const dirSpecs = [
        [config.path.folder.docsTag, getTagGroupFileContent],
        [config.path.folder.docsYear, getYearFileContent],
        [config.path.folder.property, getPropertyFileContent],
        [config.path.folder.uploader, getTagFileContent],
        [config.path.folder.tag, getTagFileContent],
    ];

    for (const [rootDirPath, fn] of dirSpecs) {
        tasks.push((async () => {
            try {
				const timerName = "timer-"+fn.name+"-"+rootDirPath;
				console.time(timerName);
                console.log("started:", fn.name, rootDirPath);
                await Promise.all(app.vault.getMarkdownFiles().filter((f) => f.path.startsWith(rootDirPath)).map(processFileWith(fn)));
                console.log("ended:", fn.name, rootDirPath);
				console.timeEnd(timerName);
            } catch (e) {
                console.error("error processing dir", rootDirPath, e);
            }
        })());
    }

	await Promise.all(tasks);

    // cleanup frontmatter
    tasks.push((async () => {
        try {
			const timerName = "timer-removeDuplicatedValueInArrayPropertyInFrontmatterForAllMarkdownFiles";
			console.time(timerName);
            console.log("started:", removeDuplicatedValueInArrayPropertyInFrontmatterForAllMarkdownFiles.name);
            await removeDuplicatedValueInArrayPropertyInFrontmatterForAllMarkdownFiles();
            console.log("ended:", removeDuplicatedValueInArrayPropertyInFrontmatterForAllMarkdownFiles.name);
			console.timeEnd(timerName);
        } catch (e) {
            console.error("error removing duplicates", e);
        }
    })());

    await Promise.all(tasks);

    console.log(`==end (time="${new Date()}")`);
    console.timeEnd("run_script");
}

main().catch((err) => console.error("unhandled error in build-index-content main:", err));
```
