---
ctime: 2025-12-17T20:55:15+08:00
mtime: 2026-01-03T22:19:01+08:00
---

# README

![](./gallery-doc/gallery-doc-image-file/image-obsidian-vault-galleries-graph-view.png)

> [!Note]
> 1. [[#pinned|#pinned]]
> 2. [[#Web Clipper|#Web Clipper]]
> 3. [[#Folder Struct|#Folder Struct]]
> 4. [[#Views of gallery-base.base|#Views of gallery-base.base]]
> 5. [[#symbols|#symbols]]
> 6. [[#Script|#Script]]

## pinned

- [[collection-gallery-items]]
- [[gallery-doc-gallery-tag]]
- [[collection-gallery-notes]]

## Web Clipper

- EXHentai Web Clipper for Obsidian | https://github.com/abc202306/exhentai-web-clipper-for-obsidian
- NHentai Web Clipper for Obsidian | https://github.com/abc202306/nhentai-web-clipper-for-obsidian

## Folder Struct

> DFC stands for the total number of descendant files

| Folder Path | DFC | DFMC | DFOC |
| :--- | ---: | ---: | ---: |
| [[gallery-doc-exhentai-uploader\|exhentai-uploader]] | 167 | 167 | 0 |
| [[gallery-doc-galleries\|galleries]] | 1404 | 702 | 702 |
| [[gallery-doc-galleries\|galleries]]/[[gallery-url-exhentai\|exhentai]] | 592 | 296 | 296 |
| [[gallery-doc-galleries\|galleries]]/[[gallery-url-exhentai\|exhentai]]/[[gallery-year-2012\|2012]] | 2 | 1 | 1 |
| [[gallery-doc-galleries\|galleries]]/[[gallery-url-exhentai\|exhentai]]/[[gallery-year-2014\|2014]] | 2 | 1 | 1 |
| [[gallery-doc-galleries\|galleries]]/[[gallery-url-exhentai\|exhentai]]/[[gallery-year-2015\|2015]] | 4 | 2 | 2 |
| [[gallery-doc-galleries\|galleries]]/[[gallery-url-exhentai\|exhentai]]/[[gallery-year-2016\|2016]] | 6 | 3 | 3 |
| [[gallery-doc-galleries\|galleries]]/[[gallery-url-exhentai\|exhentai]]/[[gallery-year-2017\|2017]] | 16 | 8 | 8 |
| [[gallery-doc-galleries\|galleries]]/[[gallery-url-exhentai\|exhentai]]/[[gallery-year-2018\|2018]] | 14 | 7 | 7 |
| [[gallery-doc-galleries\|galleries]]/[[gallery-url-exhentai\|exhentai]]/[[gallery-year-2019\|2019]] | 12 | 6 | 6 |
| [[gallery-doc-galleries\|galleries]]/[[gallery-url-exhentai\|exhentai]]/[[gallery-year-2020\|2020]] | 16 | 8 | 8 |
| [[gallery-doc-galleries\|galleries]]/[[gallery-url-exhentai\|exhentai]]/[[gallery-year-2021\|2021]] | 18 | 9 | 9 |
| [[gallery-doc-galleries\|galleries]]/[[gallery-url-exhentai\|exhentai]]/[[gallery-year-2022\|2022]] | 26 | 13 | 13 |
| [[gallery-doc-galleries\|galleries]]/[[gallery-url-exhentai\|exhentai]]/[[gallery-year-2023\|2023]] | 40 | 20 | 20 |
| [[gallery-doc-galleries\|galleries]]/[[gallery-url-exhentai\|exhentai]]/[[gallery-year-2024\|2024]] | 100 | 50 | 50 |
| [[gallery-doc-galleries\|galleries]]/[[gallery-url-exhentai\|exhentai]]/[[gallery-year-2025\|2025]] | 334 | 167 | 167 |
| [[gallery-doc-galleries\|galleries]]/[[gallery-url-exhentai\|exhentai]]/[[gallery-year-2026\|2026]] | 2 | 1 | 1 |
| [[gallery-doc-galleries\|galleries]]/[[gallery-url-nhentai\|nhentai]] | 812 | 406 | 406 |
| [[gallery-doc-galleries\|galleries]]/[[gallery-url-nhentai\|nhentai]]/[[gallery-year-2014\|2014]] | 26 | 13 | 13 |
| [[gallery-doc-galleries\|galleries]]/[[gallery-url-nhentai\|nhentai]]/[[gallery-year-2015\|2015]] | 18 | 9 | 9 |
| [[gallery-doc-galleries\|galleries]]/[[gallery-url-nhentai\|nhentai]]/[[gallery-year-2016\|2016]] | 18 | 9 | 9 |
| [[gallery-doc-galleries\|galleries]]/[[gallery-url-nhentai\|nhentai]]/[[gallery-year-2017\|2017]] | 24 | 12 | 12 |
| [[gallery-doc-galleries\|galleries]]/[[gallery-url-nhentai\|nhentai]]/[[gallery-year-2018\|2018]] | 42 | 21 | 21 |
| [[gallery-doc-galleries\|galleries]]/[[gallery-url-nhentai\|nhentai]]/[[gallery-year-2019\|2019]] | 28 | 14 | 14 |
| [[gallery-doc-galleries\|galleries]]/[[gallery-url-nhentai\|nhentai]]/[[gallery-year-2020\|2020]] | 46 | 23 | 23 |
| [[gallery-doc-galleries\|galleries]]/[[gallery-url-nhentai\|nhentai]]/[[gallery-year-2021\|2021]] | 38 | 19 | 19 |
| [[gallery-doc-galleries\|galleries]]/[[gallery-url-nhentai\|nhentai]]/[[gallery-year-2022\|2022]] | 58 | 29 | 29 |
| [[gallery-doc-galleries\|galleries]]/[[gallery-url-nhentai\|nhentai]]/[[gallery-year-2023\|2023]] | 76 | 38 | 38 |
| [[gallery-doc-galleries\|galleries]]/[[gallery-url-nhentai\|nhentai]]/[[gallery-year-2024\|2024]] | 164 | 82 | 82 |
| [[gallery-doc-galleries\|galleries]]/[[gallery-url-nhentai\|nhentai]]/[[gallery-year-2025\|2025]] | 274 | 137 | 137 |
| [[gallery-doc\|gallery-doc]] | 57 | 52 | 5 |
| [[gallery-doc-property\|gallery-doc-property]] | 33 | 33 | 0 |
| [[gallery-doc-property\|gallery-doc-property]]/[[propertyns-gallery-basic\|propertyns-gallery-basic]] | 8 | 8 | 0 |
| [[gallery-doc-property\|gallery-doc-property]]/[[propertyns-gallery-docs\|propertyns-gallery-docs]] | 1 | 1 | 0 |
| [[gallery-doc-property\|gallery-doc-property]]/[[propertyns-gallery-item\|propertyns-gallery-item]] | 23 | 23 | 0 |
| [[gallery-doc-property\|gallery-doc-property]]/[[propertyns-gallery-notes\|propertyns-gallery-notes]] | 1 | 1 | 0 |
| [[gallery-doc-templates\|gallery-doc-templates]] | 2 | 2 | 0 |
| [[gallery-doc\|gallery-doc]]/[[collection\|collection]] | 2 | 2 | 0 |
| [[gallery-doc\|gallery-doc]]/[[gallery-doc\|gallery-doc]] | 13 | 13 | 0 |
| [[gallery-doc\|gallery-doc]]/[[gallery-doc-base-file\|gallery-doc-base-file]] | 3 | 0 | 3 |
| [[gallery-doc\|gallery-doc]]/[[gallery-doc-canvas\|gallery-doc-canvas]] | 1 | 0 | 1 |
| [[gallery-doc\|gallery-doc]]/[[gallery-doc-galleries\|gallery-doc-galleries]] | 2 | 2 | 0 |
| [[gallery-doc\|gallery-doc]]/[[gallery-doc-gallery-tag\|gallery-doc-gallery-tag]] | 14 | 14 | 0 |
| [[gallery-doc\|gallery-doc]]/[[gallery-doc-image-file\|gallery-doc-image-file]] | 1 | 0 | 1 |
| [[gallery-doc\|gallery-doc]]/[[gallery-doc-notation\|gallery-doc-notation]] | 1 | 1 | 0 |
| [[gallery-doc\|gallery-doc]]/[[gallery-doc-property\|gallery-doc-property]] | 4 | 4 | 0 |
| [[gallery-doc\|gallery-doc]]/[[gallery-doc-special-keywords\|gallery-doc-special-keywords]] | 2 | 2 | 0 |
| [[gallery-doc\|gallery-doc]]/[[gallery-doc-year\|gallery-doc-year]] | 14 | 14 | 0 |
| [[collection-gallery-notes\|gallery-notes]] | 7 | 5 | 2 |
| [[gallery-doc-gallery-tag\|gallery-tag]] | 1617 | 1617 | 0 |
| [[gallery-doc-gallery-tag\|gallery-tag]]/[[exhentai-tg-artist\|exhentai-tg-artist]] | 539 | 539 | 0 |
| [[gallery-doc-gallery-tag\|gallery-tag]]/[[exhentai-tg-categories\|exhentai-tg-categories]] | 10 | 10 | 0 |
| [[gallery-doc-gallery-tag\|gallery-tag]]/[[exhentai-tg-character\|exhentai-tg-character]] | 275 | 275 | 0 |
| [[gallery-doc-gallery-tag\|gallery-tag]]/[[exhentai-tg-cosplayer\|exhentai-tg-cosplayer]] | 1 | 1 | 0 |
| [[gallery-doc-gallery-tag\|gallery-tag]]/[[exhentai-tg-female\|exhentai-tg-female]] | 252 | 252 | 0 |
| [[gallery-doc-gallery-tag\|gallery-tag]]/[[exhentai-tg-group\|exhentai-tg-group]] | 252 | 252 | 0 |
| [[gallery-doc-gallery-tag\|gallery-tag]]/[[exhentai-tg-language\|exhentai-tg-language]] | 9 | 9 | 0 |
| [[gallery-doc-gallery-tag\|gallery-tag]]/[[exhentai-tg-location\|exhentai-tg-location]] | 4 | 4 | 0 |
| [[gallery-doc-gallery-tag\|gallery-tag]]/[[exhentai-tg-male\|exhentai-tg-male]] | 54 | 54 | 0 |
| [[gallery-doc-gallery-tag\|gallery-tag]]/[[exhentai-tg-mixed\|exhentai-tg-mixed]] | 7 | 7 | 0 |
| [[gallery-doc-gallery-tag\|gallery-tag]]/[[exhentai-tg-other\|exhentai-tg-other]] | 33 | 33 | 0 |
| [[gallery-doc-gallery-tag\|gallery-tag]]/[[exhentai-tg-parody\|exhentai-tg-parody]] | 106 | 106 | 0 |
| [[gallery-doc-gallery-tag\|gallery-tag]]/[[exhentai-tg-temp\|exhentai-tg-temp]] | 1 | 1 | 0 |
| [[gallery-doc-gallery-tag\|gallery-tag]]/[[nhentai-tg-keywords\|nhentai-tg-keywords]] | 74 | 74 | 0 |

## Views of [[base-gallery.base\|gallery-base.base]]

> [!Note]
> 
> 1. [[#artist|#artist]]
> 2. [[#categories|#categories]]
> 3. [[#parody|#parody]]
> 4. [[#female|#female]]
> 5. [[#male|#male]]
> 6. [[#mixed|#mixed]]
> 7. [[#character|#character]]

### artist

> seealso: [[base-gallery.base#artist|artist]]

1. [[base-gallery.base#artist/kiira|base-gallery.base]] | 5 | [[exhentai-tag-kiira|kiira]]
2. [[base-gallery.base#artist/henreader|base-gallery.base]] | 5 | [[exhentai-tag-henreader|henreader]]
3. [[base-gallery.base#artist/utatane|base-gallery.base]] | 4 | [[exhentai-tag-utatane|utatane]]
4. [[base-gallery.base#artist/wancho|base-gallery.base]] | 5 | [[exhentai-tag-wancho|wancho]]
5. [[base-gallery.base#artist/custom-udon|base-gallery.base]] | 3 | [[exhentai-tag-custom-udon|custom-udon]]
6. [[base-gallery.base#artist/komugi|base-gallery.base]] | 3 | [[exhentai-tag-komugi|komugi]]
7. [[base-gallery.base#artist/hikami-izuto|base-gallery.base]] | 2 | [[exhentai-tag-hikami-izuto|hikami-izuto]]
8. [[base-gallery.base#artist/murai-renji|base-gallery.base]] | 1 | [[exhentai-tag-murai-renji|murai-renji]]
9. [[base-gallery.base#artist/yoyomax|base-gallery.base]] | 1 | [[exhentai-tag-yoyomax|yoyomax]]
10. [[base-gallery.base#artist/kani-biimu|base-gallery.base]] | 1 | [[exhentai-tag-kani-biimu|kani-biimu]]
11. [[base-gallery.base#artist/baku-p|base-gallery.base]] | 1 | [[exhentai-tag-baku-p|baku-p]]

### categories

> seealso: [[base-gallery.base#categories|categories]]

1. [[base-gallery.base#categories/doujinshi|base-gallery.base]] | 463 | [[exhentai-tag-doujinshi|doujinshi]]
2. [[base-gallery.base#categories/manga|base-gallery.base]] | 114 | [[exhentai-tag-manga|manga]]
3. [[base-gallery.base#categories/image-set|base-gallery.base]] | 37 | [[exhentai-tag-image-set|image-set]]
4. [[base-gallery.base#categories/misc|base-gallery.base]] | 23 | [[exhentai-tag-misc|misc]]
5. [[base-gallery.base#categories/artist-cg|base-gallery.base]] | 33 | [[exhentai-tag-artist-cg|artist-cg]]
6. [[base-gallery.base#categories/game-cg|base-gallery.base]] | 8 | [[exhentai-tag-game-cg|game-cg]]
7. [[base-gallery.base#categories/non-h|base-gallery.base]] | 4 | [[exhentai-tag-non-h|non-h]]
8. [[base-gallery.base#categories/western|base-gallery.base]] | 1 | [[exhentai-tag-western|western]]

### parody

> seealso: [[base-gallery.base#parody|parody]]

1. [[base-gallery.base#parody/original|base-gallery.base]] | 193 | [[exhentai-tag-original|original]]
2. [[base-gallery.base#parody/blue-archive|base-gallery.base]] | 93 | [[exhentai-tag-blue-archive|blue-archive]]
3. [[base-gallery.base#parody/touhou-project|base-gallery.base]] | 25 | [[exhentai-tag-touhou-project|touhou-project]]
4. [[base-gallery.base#parody/mahoujin-guru-guru|base-gallery.base]] | 20 | [[exhentai-tag-mahoujin-guru-guru|mahoujin-guru-guru]]

### female

1. [[base-gallery.base#female/lolicon|base-gallery.base]] | 644 | [[exhentai-tag-lolicon|lolicon]]
2. [[base-gallery.base#female/rape|base-gallery.base]] | 106 | [[exhentai-tag-rape|rape]]

### male

1. [[base-gallery.base#male/sole-male|base-gallery.base]] | 293 | [[exhentai-tag-sole-male|sole-male]]

### mixed

1. [[base-gallery.base#mixed/kodomo-doushi|base-gallery.base]] | 27 | [[exhentai-tag-kodomo-doushi|kodomo-doushi]]

### character

1. [[base-gallery.base#character/kukuri|base-gallery.base]] | 19 | [[exhentai-tag-kukuri|kukuri]]

## symbols

> [!Note]
> - symbol-type
> 	- PREFIX | #PREFIX
> 	- NONE | #NONE
> 	- FILE | #FILE
> - symbol-tag
> 	- GROUPED | #GROUPED 


| FOLDER                                       | FILE                                                                                                                             | SYMBOL-TYPE | SYMBOL-TAG |
| -------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------- | ----------- | ---------- |
| `/`                                          | `"README.md"`                                                                                                                    | #FILE       |            |
| `/exhentai-uploader/`                        | `/^exhentai-uploader-(?<uploaderName>.+)\.md/`                                                                                   | #PREFIX     |            |
| `/galleries/exhentai/`                       | `/^(?<yearUploaded>\d{4})\/exhentai-g-(?<exhentaiGalleryID>\d+)-(?<exhentaiGalleryToken>.+)\.(?<extension>md\|png\|jpg\|webp)$/` | #PREFIX     | #GROUPED   |
| `/galleries/nhentai/`                        | `/^(?<yearUploaded>\d{4})\/nehentai-g-(?<nhentaiGalleryID>\d+)\.(?<extension>md\|png\|jpg\|webp)$/`                              | #PREFIX     | #GROUPED   |
| `/gallery-doc-property/`                     | `/^(?<propertyNameSpaceName>.+)\/property-(?<propertyName>.+)\.md$/`                                                             | #PREFIX     | #GROUPED   |
| `/gallery-doc-templates/`                    | `/^template-(?<templateName>.+)\.md$/`                                                                                           | #PREFIX     |            |
| `/gallery-doc/collection/`                   | `/^collection-(?<collectionName>gallery-.+)\.md$/`                                                                               | #PREFIX     |            |
| `/gallery-doc/gallery-doc-base-file/`        | `/^base-(?<baseItemName>.+)\.base$/`                                                                                             | #PREFIX     |            |
| `/gallery-doc/gallery-doc-canvas/`           | `/^canvas-(?<canvasName>.+)\.canvas$/`                                                                                           | #PREFIX     |            |
| `/gallery-doc/gallery-doc-galleries/`        | `/^gallery-url-(?<galleryUrlTypeName>.+)\.md$/`                                                                                  | #PREFIX     |            |
| `/gallery-doc/gallery-doc-image-file/`       | `/^image-(?<imageName>.+)\.png$/`                                                                                                | #PREFIX     |            |
| `/gallery-doc/gallery-doc-notation/`         | `/^notation-(?<notationName>.+)\.md$/`                                                                                           | #PREFIX     |            |
| `/gallery-doc/gallery-doc-property/`         | `/^propertyns-(?<propertyNameSpaceName>.+)\.md$/`                                                                                | #PREFIX     |            |
| `/gallery-doc/gallery-doc-special-keywords/` | `/^(?<fileBaseName>.+)\.md$/`                                                                                                    | #NONE       |            |
| `/gallery-doc/gallery-doc-year/`             | `/^gallery-year-(?<year>\d{4})\.md$/`                                                                                            | #PREFIX     |            |
| `/gallery-doc/gallery-doc/`                  | `/^gallery-doc-(?<galleryDocName>.+)\.md$/`                                                                                      | #PREFIX     |            |
| `/gallery-doc/gallery-tag/`                  | `/^(ex\|n)hentai-tg-(?<tagNameSpaceName>.+)\.md$/`                                                                               | #PREFIX     |            |
| `/gallery-notes/`                            | `/gallery-note-(?<date>\d{4}-\d{2}-\d{2})\s(?<noteTitle>.*)^\.md$/`                                                              | #PREFIX     |            |
| `/gallery-notes/`                            | `"base-galley-note.base"`                                                                                                        | #FILE       |            |
| `/gallery-tag/`                              | `/^(ex\|n)hentai-tg-(?<tagNameSpaceName>.+)\/exhentai-tag-(?<exhentaiTagName>.+)\.md$/`                                          | #PREFIX     | #GROUPED   |

## Script

### Build Index Content

```js

const config = {
    path: {
        folder: {
            tag: "gallery-tag/", //type/rewrite
            gallery: "galleries/", //type/rewrite
            property: "gallery-doc-property/", //type/rewrite
            uploader: "exhentai-uploader/", //type/rewrite
            docsTag: "gallery-doc/gallery-doc-gallery-tag/", //type/rewrite
            docsYear: "gallery-doc/gallery-doc-year/", //type/rewrite
        },
        file: {
            readme: "README.md", //type/replace
            tag: "gallery-doc/gallery-doc/gallery-doc-gallery-tag.md", //type/rewrite
            uploader: "gallery-doc/gallery-doc/gallery-doc-exhentai-uploader.md", //type/rewrite
            galleryNotes: "gallery-doc/collection/collection-gallery-notes.md", //type/replace
            gallery: "gallery-doc/collection/collection-gallery-items.md", //type/replace
            exhentai: "gallery-doc/gallery-doc-galleries/gallery-url-exhentai.md", //type/replace
            nhentai: "gallery-doc/gallery-doc-galleries/gallery-url-nhentai.md", //type/replace
        },
    },
	ref: {
		docs: {
			docs: "[[gallery-doc|gallery-doc]]",
			tag: "[[gallery-doc-gallery-tag|gallery-doc-gallery-tag]]",
			collection: "[[collection|collection]]",
		},
		base: {
			galleryDynamicBase: "[[base-gallery-dynamic.base|base-gallery-dynamic.base]]",
			propertyDynamicBase: "[[base-property-dynamic.base|base-property-dynamic.base]]",
			galleryBase: "[[base-gallery.base|base-gallery.base]]",
		},
		galleryTagGroup: {
			artist: "[[exhentai-tg-artist|artist]]",
			categories: "[[exhentai-tg-categories|categories]]",
			character: "[[exhentai-tg-character|character]]",
			cosplayer: "[[exhentai-tg-cosplayer|cosplayer]]",
			female: "[[exhentai-tg-female|female]]",
			group: "[[exhentai-tg-group|group]]",
			keywords: "[[nhentai-tg-keywords|keywords]]",
			language: "[[exhentai-tg-language|language]]",
			location: "[[exhentai-tg-location|location]]",
			male: "[[exhentai-tg-male|male]]",
			mixed: "[[exhentai-tg-mixed|mixed]]",
			other: "[[exhentai-tg-other|other]]",
			parody: "[[exhentai-tg-parody|parody]]",
			temp: "[[exhentai-tg-temp|temp]]"
		},
		collection: {
			gallery: "[[collection-gallery-items|collection-gallery-items]]",
			galleryNotes: "[[collection-gallery-notes|collection-gallery-notes]]",
		},
	},
	keywords: {
		exhentai: "exhentai",
		nhentai: "nhentai",
		galleryItems: "gallery-items",
		noteList: "note-list",
	},
	propertyNames: [
        "artist",
        "group",
        "categories",
        "character",
        "parody",
        "language",
        "cosplayer",
        "female",
        "location",
        "male",
        "mixed",
        "other",
        "temp",
        "keywords",
		"uploader",
    ]
};

function getLocalISOStringWithTimezone() {
    const date = new Date();
    const pad = (n) => String(n).padStart(2, "0");

    const offset = -date.getTimezoneOffset();
    const sign = offset >= 0 ? "+" : "-";
    const hours = pad(Math.floor(Math.abs(offset) / 60));
    const minutes = pad(Math.abs(offset) % 60);

    return (
        `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}T` +
        `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}` +
        `${sign}${hours}:${minutes}`
    );
}

// Utility helpers to avoid relying on environment-specific prototype extensions
function uniqueArray(arr) {
    return Array.from(new Set(arr));
}

function groupBy(array, keyFn) {
    const map = new Map();
    for (const item of array) {
        const key = keyFn(item);
        const list = map.get(key) || [];
        list.push(item);
        map.set(key, list);
    }
    return Array.from(map.entries());
}

function safeArray(v) {
    if (!v) return [];
    return Array.isArray(v) ? v : [v];
}

function compareGalleryPathWithPropertyUploaded(path1, path2) {
    const f1 = app.vault.getAbstractFileByPath(path1);
    const f2 = app.vault.getAbstractFileByPath(path2);
    const fc1 = app.metadataCache.getFileCache(f1);
    const fc2 = app.metadataCache.getFileCache(f2);
    const v1 = String(fc1?.frontmatter?.uploaded || "_");
    const v2 = String(fc2?.frontmatter?.uploaded || "_");
    // sort descending
    const result = v2.localeCompare(v1);
	if (result !== 0) {
		return result;
	}
	return path2.localeCompare(path1);
}

function getGalleryPathRepresentationStr(path) {
    const f2 = app.vault.getAbstractFileByPath(path);
    const linktext2 = app.metadataCache.fileToLinktext(f2);
    const fc2 = app.metadataCache.getFileCache(f2) || {};

	const dateUploaded = fc2.frontmatter?.uploaded?.substring(0,10);
	const postDescription = dateUploaded?` | ${dateUploaded}`:"";
	
    const display2 = fc2.frontmatter?.japanese || fc2.frontmatter?.english || linktext2;
    const link2 =
        display2 === linktext2
            ? `| [[${linktext2}|${linktext2}]]`
            : `\u001C${display2}\u001C | [[${linktext2}|${linktext2}]]`.replace(/\u001C/g, "`");

    const coverField = fc2.frontmatter?.cover;
    let coverEmbed = "";
    if (coverField) {
        const res = /^\[\[(?<linktext3>[^\|]*)\|?.*\]\]$/.exec(coverField);
        coverEmbed = res
            ? `\n\t- ![[${res.groups.linktext3}|200]]`
            : `\n\t- ![200](${coverField})`;
    }

    return `1. ${link2}${postDescription}${coverEmbed}`;
}

function getNGStr(nonGalleryNotePaths) {
    const ngls = [...nonGalleryNotePaths].sort();
    return ngls
        .map((path) => `[[${app.metadataCache.fileToLinktext(app.vault.getAbstractFileByPath(path))}|${app.metadataCache.fileToLinktext(app.vault.getAbstractFileByPath(path))}]]`)
        .join(", ");
}

function getGStrASList(galleryNotePaths) {
    const gls = [...galleryNotePaths].sort(compareGalleryPathWithPropertyUploaded);
    return gls.map(getGalleryPathRepresentationStr).join("\n");
}

function getGStrASGroupedList(galleryNotePaths) {
    const gls = [...galleryNotePaths].sort(compareGalleryPathWithPropertyUploaded);
    const grouped = groupBy(gls, (gnPath) => getYear(app.vault.getAbstractFileByPath(gnPath)));
    const parts = grouped
        .sort((a, b) => b[0].localeCompare(a[0]))
        .flatMap(([key, group]) => {
			const grouped02 = groupBy(group, (gnPath) => getMonth(app.vault.getAbstractFileByPath(gnPath)));
			const parts02 = grouped02
		        .sort((a, b) => b[0].localeCompare(a[0]))
				.flatMap(([key02, group02]) => [
					`#### ${key02}`,
					group02.map(getGalleryPathRepresentationStr).join("\n")
				])
			return [
				`### ${key}`,
				...parts02
			]
		});
    return parts.join("\n\n");
}

function getGStr(galleryNotePaths) {
    return getGStrASGroupedList(galleryNotePaths);
}

function getTagFileContent(title, ctime, mtime) {
    const f = app.metadataCache.getFirstLinkpathDest(title);
    const backlinks = app.metadataCache.getBacklinksForFile(f)?.data;
    const paths = backlinks ? [...backlinks.keys()] : [];

    const ngstr = getNGStr(
        paths.filter((i) => !i.startsWith(config.path.folder.gallery)).filter((i) => i !== config.path.file.readme)
    );
    const gstr = getGStr(paths.filter((i) => i.startsWith(config.path.folder.gallery)));

    return `---\nctime: ${ctime}\nmtime: ${mtime}\n---\n\n# ${title}\n\n> seealso: ${ngstr}\n\n!${config.ref.base.galleryDynamicBase}\n\n## ${config.keywords.galleryItems}\n\n${gstr}\n`;
}

function getYearFileContent(title, ctime, mtime) {
    const f = app.metadataCache.getFirstLinkpathDest(title);
    const backlinks = app.metadataCache.getBacklinksForFile(f)?.data;
    const paths = backlinks ? [...backlinks.keys()] : [];

    const ngstr = getNGStr(
        paths.filter((i) => !i.startsWith(config.path.folder.gallery)).filter((i) => i !== config.path.file.readme)
    );

	const year = title.replace(/^gallery-year-/,"");

    const galleryNotePaths = app
        .vault
        .getMarkdownFiles()
        .filter((f) => f.path.startsWith(config.path.folder.gallery))
        .filter((f) => getYear(f) === year)
        .map((f) => f.path);
    const gstr = getGStr(galleryNotePaths);

    return `---\nctime: ${ctime}\nmtime: ${mtime}\n---\n\n# ${title}\n\n> seealso: ${ngstr}\n\n## ${config.keywords.galleryItems}\n\n${gstr}\n`;
}

function toFileName(wikilinkStr) {
	return /^\[\[(?<fn>[^\|]*?)\|.*?\]\]$/.exec(wikilinkStr).groups.fn || /^\[\[(?<fn>[^\|]*?)\]\]$/.exec(wikilinkStr).groups.fn || "_";
}

function getTagGroupMOC(title) {
    const property = title.replace(/^(gallery-doc-)?((ex|n)hentai-)?(tg-)?/, "");
    const galleryMDFileCaches = app
        .vault
        .getMarkdownFiles()
        .filter((f) => f.path.startsWith(config.path.folder.gallery))
        .map((f) => app.metadataCache.getFileCache(f) || {});

    const allValues = galleryMDFileCaches.flatMap((fc) => safeArray((fc.frontmatter || {})[property]));
    const uniqueValues = uniqueArray(allValues).filter((v) => v);

    return uniqueValues
        .sort((a, b) => toFileName(a).localeCompare(toFileName(b)))
        .map((v) =>
            `1. ${v} | ${galleryMDFileCaches.filter((fc) => safeArray((fc.frontmatter || {})[property]).includes(v)).length}`
        )
        .join("\n");
}

function getGroupFileContent(title, ctime, mtime, seealso) {
    return `---\nctime: ${ctime}\nmtime: ${mtime}\n---\n\n# ${title}\n\n> seealso: ${seealso}\n\n${getTagGroupMOC(title)}\n`;
}

function getTagCount(tagNameSpaceStr) {
	const result01 = /^\[\[(.*)\|(.*)\]\]$/.exec(tagNameSpaceStr);
	const result02 = /^\[\[(.*)\]\]$/.exec(tagNameSpaceStr);
	const str = result01?.[1] || result02?.[1] || tagNameSpaceStr;
    const property = str.replace(/^(ex|n)hentai-tg-/, "");
    const galleryMDFileCaches = app
        .vault
        .getMarkdownFiles()
        .filter((f) => f.path.startsWith(config.path.folder.gallery))
        .map((f) => app.metadataCache.getFileCache(f) || {});

    return uniqueArray(galleryMDFileCaches.flatMap((fc) => safeArray((fc.frontmatter || {})[property]))).filter((v) => v)
        .length;
}

function getTagMetaFileContent(_title, ctime, mtime) {
	const {docs} = config.ref.docs;
	const {artist, categories, character, cosplayer, female, group, keywords, language, location, male, mixed, other, parody, temp} = config.ref.galleryTagGroup;
    return `---\nctime: ${ctime}\nmtime: ${mtime}\n---\n\n# tag\n\n> seealso: ${docs}\n\n1. ${artist} | ${getTagCount(artist)}\n1. ${categories} | ${getTagCount(categories)}\n1. ${character} | ${getTagCount(character)}\n1. ${cosplayer} | ${getTagCount(cosplayer)}\n1. ${female} | ${getTagCount(female)}\n1. ${group} | ${getTagCount(group)}\n1. ${keywords} | ${getTagCount(keywords)}\n1. ${language} | ${getTagCount(language)}\n1. ${location} | ${getTagCount(location)}\n1. ${male} | ${getTagCount(male)}\n1. ${mixed} | ${getTagCount(mixed)}\n1. ${other} | ${getTagCount(other)}\n1. ${parody} | ${getTagCount(parody)}\n1. ${temp} | ${getTagCount(temp)}\n`;
}

function getTagGroupFileContent(title, ctime, mtime) {
    return getGroupFileContent(title, ctime, mtime, config.ref.docs.tag);
}

function getUploaderGroupFileContent(title, ctime, mtime) {
    return getGroupFileContent(title, ctime, mtime, config.ref.docs.docs);
}

function getPropertyFileContent(title, ctime, mtime) {
    const f = app.metadataCache.getFirstLinkpathDest(title);
    const backlinks = app.metadataCache.getBacklinksForFile(f)?.data;
    const paths = backlinks ? [...backlinks.keys()] : [];

    const ngstr = getNGStr(
        paths.filter((i) => !i.startsWith(config.path.folder.gallery)).filter((i) => i !== config.path.file.readme)
    );

    return `---\nctime: ${ctime}\nmtime: ${mtime}\n---\n\n# ${title}\n\n> seealso: ${ngstr}\n\n!${config.ref.base.propertyDynamicBase}\n`;
}

function getRenderedFolderPathPart(part) {
	const file01 = app.metadataCache.getFirstLinkpathDest(part);
	if (file01) {
		return `[[${part}\\|${part}]]`;
	}
	const file02 = app.metadataCache.getFirstLinkpathDest(`gallery-doc-${part}`) || app.metadataCache.getFirstLinkpathDest(`gallery-url-${part}`) || app.metadataCache.getFirstLinkpathDest(`gallery-year-${part}`) || app.metadataCache.getFirstLinkpathDest(`collection-${part}`);
	if (file02) {
		return `[[${file02.basename}\\|${part}]]`;
	}
	return `${part}`;
}

function getRenderedFolderPath(folder) {
    return folder.path.split("/").map((part) => getRenderedFolderPathPart(part)).join("/");
}



function getDecendantFilesCount(folder, files, extension=/.*/) {
    return files.filter((f) => f.path.startsWith(folder.path + "/") && extension.exec(f.extension)).length;
}

function replaceFrontMatter(fileContent, ctime, mtime, preFMBlock = "") {
    return `---${preFMBlock}\nctime: ${ctime}\nmtime: ${mtime}\n---\n` + fileContent.replace(/^---\r?\n[^]*?(?<=\n)---\r?\n/, "");
}

async function getReadmeFileContent(_title, ctime, mtime) {
    const file = app.vault.getAbstractFileByPath(config.path.file.readme);
    const fileContent = await app.vault.read(file);

    const files = app.vault.getFiles();
    const folders = app.vault.getAllFolders().sort((a, b) => a.path.localeCompare(b.path));

    const tableStr = `| Folder Path | DFC | DFMC | DFOC |\n| :--- | ---: | ---: | ---: |\n${folders
        .map((folder) => `| ${getRenderedFolderPath(folder)} | ${getDecendantFilesCount(folder, files, /.*/)} | ${getDecendantFilesCount(folder, files, /^md$/)} | ${getDecendantFilesCount(folder, files, /^(?!md$)/)} |`)
        .join("\n")}`;

    const newData = replaceFrontMatter(fileContent, ctime, mtime).replace(
        /(?<=\n)## Folder Struct\n[^#]*(?=\n##\s)/,
        "## Folder Struct\n\n> DFC stands for the total number of descendant files\n\n" + tableStr + "\n"
    );

    return newData;
}

async function getNoteMetaFileContent(_title, ctime, mtime) {
    const metaFilePath = config.path.file.galleryNotes;
    const noteFiles = app
        .vault
        .getMarkdownFiles()
        .filter((f) => safeArray(app.metadataCache.getFileCache(f)?.frontmatter?.up).includes(config.ref.collection.galleryNotes));

    const file = app.vault.getAbstractFileByPath(metaFilePath);
    const fileContent = await app.vault.read(file);

    const gls = noteFiles
        .sort((f1, f2) => {
            const fc1 = app.metadataCache.getFileCache(f1) || {};
            const fc2 = app.metadataCache.getFileCache(f2) || {};
            const v1 = fc1.frontmatter?.ctime || "_";
            const v2 = fc2.frontmatter?.ctime || "_";
            return v2.localeCompare(v1);
        })
        .map((f) => f.path);

    const gstr = gls.map(getGalleryPathRepresentationStr).join("\n");

    const preFMBlock = `\nup:\n  - "${config.ref.docs.collection}"`;
    const newData = replaceFrontMatter(fileContent, ctime, mtime, preFMBlock).replace(new RegExp(`(?<=\n)## ${config.keywords.noteList}\n[^]*`),
        `## ${config.keywords.noteList}\n\n${gstr}\n`
    );

    return newData;
}


async function getGalleryMetaFileContentWithSpecPath(_title, ctime, mtime, metaFilePath, galleryNoteFiles, preFMBlock = "") {
    const file = app.vault.getAbstractFileByPath(metaFilePath);
    const fileContent = await app.vault.read(file);

    const gstr = getGStr(galleryNoteFiles.map((f) => f.path));

    const newData = replaceFrontMatter(fileContent, ctime, mtime, preFMBlock).replace(new RegExp(`(?<=\n)## ${config.keywords.galleryItems}\n[^]*`),
        `## ${config.keywords.galleryItems}\n\n${gstr}\n`
    );

    return newData;
}

async function getSpecGalleryMetaFileContent(_title, ctime, mtime) {
    const metaFilePath = config.path.file.gallery;
    const galleryNoteFiles = app
        .vault
        .getMarkdownFiles()
        .filter((f) => safeArray(app.metadataCache.getFileCache(f)?.frontmatter?.up).includes(config.ref.collection.gallery));
    const preFMBlock = `\nup:\n  - "${config.ref.docs.collection}"\nbases:\n  - "${config.ref.base.galleryBase}"`;
    return await getGalleryMetaFileContentWithSpecPath(_title, ctime, mtime, metaFilePath, galleryNoteFiles, preFMBlock);
}

async function getSpecEXHentaiGalleryMetaFileContent(_title, ctime, mtime) {
    const metaFilePath = config.path.file.exhentai;
    const galleryNoteFiles = app
        .vault
        .getMarkdownFiles()
        .filter((f) => safeArray(app.metadataCache.getFileCache(f)?.frontmatter?.up).includes(config.ref.collection.gallery))
        .filter((f) => (app.metadataCache.getFileCache(f)?.frontmatter?.url || "").includes(config.keywords.exhentai));
    return await getGalleryMetaFileContentWithSpecPath(_title, ctime, mtime, metaFilePath, galleryNoteFiles);
}

async function getSpecNHentaiGalleryMetaFileContent(_title, ctime, mtime) {
    const metaFilePath = config.path.file.nhentai;
    const galleryNoteFiles = app
        .vault
        .getMarkdownFiles()
        .filter((f) => safeArray(app.metadataCache.getFileCache(f)?.frontmatter?.up).includes(config.ref.collection.gallery))
        .filter((f) => (app.metadataCache.getFileCache(f)?.frontmatter?.url || "").includes(config.keywords.nhentai));
    return await getGalleryMetaFileContentWithSpecPath(_title, ctime, mtime, metaFilePath, galleryNoteFiles);
}

async function getFileContent(file, data, getSpecTypeFileContent) {
    const title = file.basename;
    const fileCache = app.metadataCache.getFileCache(file) || {};

    const ctimeInFrontMatter = fileCache.frontmatter?.ctime;
    const mtimeInFrontMatter = fileCache.frontmatter?.mtime;

    const mtime = getLocalISOStringWithTimezone();
    const ctime = ctimeInFrontMatter || mtime;

    const formattedData = data.replace(/\r/g, "");

    const newData1 = await getSpecTypeFileContent(title, ctimeInFrontMatter, mtimeInFrontMatter);
    if (formattedData === newData1) return data;

    const newData2 = await getSpecTypeFileContent(title, ctime, mtime);
    return newData2;
}

function processFileWith(getSpecTypeFileContent) {
    return async function processFileWrapper(file) {
        const originalData = await app.vault.read(file);
        const newData = await getFileContent(file, originalData, getSpecTypeFileContent);
        if (newData !== originalData) {
            await app.vault.process(file, () => newData);
        }
    };
}

function removeDuplicatedValueInArrayPropertyInFrontmatterForAllMarkdownFiles() {
    app.vault.getMarkdownFiles().forEach((f) => {
        const fc = app.metadataCache.getFileCache(f) || {};
        if (!fc.frontmatter) return;
        for (const k of Object.keys(fc.frontmatter)) {
            const v1 = fc.frontmatter[k];
            if (!Array.isArray(v1)) continue;
            const v2 = uniqueArray(v1);
            if (v2.length === v1.length) continue;
            app.fileManager.processFrontMatter(f, (fm) => {
                fm[k] = v2;
            });
        }
    });
}

function createFilesFromUnresolvedLinksForAllGalleryNoteFiles() {
    const galleryNoteMDFiles = app.vault.getMarkdownFiles().filter((f) => f.path.startsWith(config.path.folder.gallery));
    const unresolvedLinktexts = galleryNoteMDFiles.flatMap((f) => Object.keys(app.metadataCache.unresolvedLinks?.[f.path] || {}));

	console.log("unresolvedLinktexts",unresolvedLinktexts)

    const galleryMDFileCaches = galleryNoteMDFiles.map((f) => app.metadataCache.getFileCache(f) || {});
    for (const linktext of uniqueArray(unresolvedLinktexts)) {
        const value = `[[${linktext}|${linktext}]]`;
        const propertyName = config.propertyNames.find((pn) =>
            galleryMDFileCaches.filter((fc) => safeArray((fc.frontmatter || {})[pn]).includes(value)).length !== 0
        );

        let folderPath = config.path.folder.tag;

        const destPath = folderPath + linktext + ".md";
        try {
            if (!app.vault.getAbstractFileByPath(destPath)) {
                app.vault.create(destPath, "")
					.then((f)=>app.metadataCache.getFileCache(f));
            }
        } catch (e) {
            // ignore creation errors (file may exist already or race conditions)
        }
    }
}

function getProcessFilePromise(path, getSpecTypeFileContent) {
    const file = app.vault.getAbstractFileByPath(path);
    const fileProcesser = processFileWith(getSpecTypeFileContent);
    return fileProcesser(file);
}

function getYear(galleryNoteFile) {
    return app.metadataCache.getFileCache(galleryNoteFile)?.frontmatter?.uploaded?.slice(0, 4) || "1000";
}

function getMonth(galleryNoteFile) {
    return app.metadataCache.getFileCache(galleryNoteFile)?.frontmatter?.uploaded?.slice(0, 7) || "1000-01";
}

function batchMoveGalleryNoteFilesByYearUploaded() {
    const files = app.vault.getFiles();
    const mdfiles = app.vault.getMarkdownFiles();
    const candidates = mdfiles.filter((f) => f.path.startsWith(config.path.folder.gallery));

    for (const f of candidates) {
        if (f.path.split("/").length !== 3) continue;
        const year = getYear(f);
        const folderPath = `${f.parent.path}/${year}`;
        if (!app.vault.getFolderByPath(folderPath)) app.vault.createFolder(folderPath);
    }

    for (const f of candidates) {
        if (f.path.split("/").length !== 3) continue;
        const year = app.metadataCache.getFileCache(f)?.frontmatter?.uploaded?.slice(0, 4);
        const folderPath = `${f.parent.path}/${year}`;
        if (!app.vault.getFolderByPath(folderPath)) app.vault.createFolder(folderPath);
        const pathPrefix = `${f.parent.path}/${f.basename}`;
        files.filter((f2) => f2.path.startsWith(pathPrefix)).forEach((f2) => {
            const newPath2 = `${folderPath}/${f2.name}`;
            app.vault.rename(f2, newPath2);
            console.log(newPath2);
        });
    }
}

function stardandnizeGalleryNoteCoverFileName() {
	const galleryNoteFiles = app.vault.getMarkdownFiles().filter(f=>f.path.startsWith(config.path.folder.gallery));
	galleryNoteFiles.filter(f=>{
	    const cover = app.metadataCache.getFileCache(f)?.frontmatter?.cover;
	    const res = /^\[\[(.*?\|)?(?<basename>.*)\.(?<extension>.*)\]\]$/.exec(cover)
	    if (!res){
	        return;
	    }
	    const coverBasename = res.groups.basename;
	    const coverExtension = res.groups.extension;
	    const coverLinktext = `${coverBasename}.${coverExtension}`;
	    const coverFile = app.metadataCache.getFirstLinkpathDest(coverLinktext);
	    const newCoverLinktext = `${f.basename}.${coverExtension}`;
		const newPath = `${coverFile.parent.path}/${newCoverLinktext}`
	    if (!cover?.startsWith("[["+f.basename)) {
	        app.fileManager.renameFile(coverFile,newCoverLinktext);
	        console.log(coverFile.name,newPath);
	    }
	})
}

function refreshCache(){
	app.vault.getMarkdownFiles().forEach((f)=>app.metadataCache.getFileCache(f));
}

async function main() {
    console.time("run_script");
    console.log(`==start (time="${new Date()}")`);
	
    const tasks = [];

    // preparatory runs
	tasks.push(refreshCache());

	await Promise.all(tasks);
	
	tasks.push(createFilesFromUnresolvedLinksForAllGalleryNoteFiles());
    tasks.push(batchMoveGalleryNoteFilesByYearUploaded());
	tasks.push(stardandnizeGalleryNoteCoverFileName());

	await Promise.all(tasks);

    // single-file generators
    const singleFileSpecs = [
        [config.path.file.readme, getReadmeFileContent],
        [config.path.file.uploader, getUploaderGroupFileContent],
        [config.path.file.tag, getTagMetaFileContent],
        [config.path.file.galleryNotes, getNoteMetaFileContent],
        [config.path.file.gallery, getSpecGalleryMetaFileContent],
        [config.path.file.exhentai, getSpecEXHentaiGalleryMetaFileContent],
        [config.path.file.nhentai, getSpecNHentaiGalleryMetaFileContent],
    ];

    for (const [path, fn] of singleFileSpecs) {
        tasks.push((async () => {
            try {
				const timerName = "timer-"+fn.name+"-"+path;
				console.time(timerName);
                console.log("started:", fn.name, path);
                await getProcessFilePromise(path, fn);
                console.log("ended:", fn.name, path);
				console.timeEnd(timerName);
            } catch (e) {
                console.error("error processing", path, e);
            }
        })());
    }

	await Promise.all(tasks);
	
	tasks.push(refreshCache());
	
    // directory-scoped generators
    const dirSpecs = [
        [config.path.folder.docsTag, getTagGroupFileContent],
        [config.path.folder.docsYear, getYearFileContent],
        [config.path.folder.property, getPropertyFileContent],
        [config.path.folder.uploader, getTagFileContent],
        [config.path.folder.tag, getTagFileContent],
    ];

    for (const [rootDirPath, fn] of dirSpecs) {
        tasks.push((async () => {
            try {
				const timerName = "timer-"+fn.name+"-"+rootDirPath;
				console.time(timerName);
                console.log("started:", fn.name, rootDirPath);
                await Promise.all(app.vault.getMarkdownFiles().filter((f) => f.path.startsWith(rootDirPath)).map(processFileWith(fn)));
                console.log("ended:", fn.name, rootDirPath);
				console.timeEnd(timerName);
            } catch (e) {
                console.error("error processing dir", rootDirPath, e);
            }
        })());
    }

	await Promise.all(tasks);

    // cleanup frontmatter
    tasks.push((async () => {
        try {
			const timerName = "timer-removeDuplicatedValueInArrayPropertyInFrontmatterForAllMarkdownFiles";
			console.time(timerName);
            console.log("started:", removeDuplicatedValueInArrayPropertyInFrontmatterForAllMarkdownFiles.name);
            await removeDuplicatedValueInArrayPropertyInFrontmatterForAllMarkdownFiles();
            console.log("ended:", removeDuplicatedValueInArrayPropertyInFrontmatterForAllMarkdownFiles.name);
			console.timeEnd(timerName);
        } catch (e) {
            console.error("error removing duplicates", e);
        }
    })());

    await Promise.all(tasks);

    console.log(`==end (time="${new Date()}")`);
    console.timeEnd("run_script");
}

main().catch((err) => console.error("unhandled error in build-index-content main:", err));
```
